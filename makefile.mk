################################################################################
# SECTION 1: VARIABLES & CONFIGURATION
################################################################################

.ONESHELL:

# Load user overrides first
-include vars.mk

# Source .env file if it exists
ifneq (,$(wildcard .env))
    include .env
    export
endif

DRY_RUN                     ?= 0

# Core configuration
RECREATE                    ?= 0
SCRIPT_DEBUG                ?= 0
RESET_VENV                  ?= 0
BUILD_DATE                  := $(shell date -u +'%Y-%m-%dT%H:%M:%SZ%:z')
BUILD_EPOCH                 := $(shell date -u +'%s')

# Base image

# Git & SCM variables
GIT_WEB_URL                 ?= https://github.com/openshift-kni/eco-ci-cd
GIT_COMMIT_HASH             ?= $(shell git rev-parse HEAD)
GIT_TAG                     ?= $(shell git tag --points-at=HEAD 2>/dev/null)

# Python environment
PYTHON_VERSION              ?= 3.12
IMAGE_PYTHON_VERSION        ?= 3.12
PY_EXEC                     ?= python$(PYTHON_VERSION)
VENV_DIR                    ?= .venv
IMAGE_VENV_ENABLE           ?= 1
PY_REQS                     ?= pip

# Base image configuration
BASE_TAG                    ?= latest
# BASE_IMAGE                  ?= registry.redhat.io/ubi9/ubi-minimal
# PKG_MANAGER                 ?= microdnf
# PKG_MANAGER_OPTS            ?= --nodocs --setopt=install_weak_deps=0

PKG_MANAGER					?= dnf
PKG_MANAGER_OPTS			?= --setopt=install_weak_deps=False --setopt=tsdocs=False

# Container image configuration
NAME                  		?= $(notdir $(GIT_WEB_URL))
REGISTRY              		?= quay.io
NAMESPACE              		?= telcov10n-ci
IMAGE_FULL_NAME             ?= $(REGISTRY)/$(NAMESPACE)/$(NAME)
IMAGE_TAG                   ?= $(GIT_TAG)

# Podman configuration
PODMAN_PARAMS               ?=
PODMAN_BUILD_PARAMS         ?= "--platform" "linux/amd64"
PODMAN_TAG_PARAMS           ?=
PODMAN_PUSH_PARAMS          ?=
BUILD_ARGS_FILE             ?= $(NAME)-$(BUILD_EPOCH)-build-args.txt
USE_OC                      ?= 1
USE_KUBECTL                 ?= 0
STRIP_BINARIES              ?= 1

# Execution Environment configuration
EE_NAME                     ?= $(NAME)-ee
EE_DIR                      ?= $(EE_NAME)-ubi-amd64
EE_FULL_NAME                ?= $(REGISTRY)/$(NAMESPACE)/$(EE_NAME)
EE_TAG                      ?= $(GIT_COMMIT_HASH)
EE_PY_REQS                  ?= requirements-ee
EE_NAV_PLAYBOOK             ?= playbooks/report-send.yml
EE_NAV_MODE                 ?= stdout
EE_NAV_PULL_POLICY          ?= missing
EE_NAV_EXTRA_VARS           ?=

# Testing configuration
RUN_PLAYBOOK                ?= report-send.yml
TEST_PLAYBOOK               ?= test-$(RUN_PLAYBOOK)
INVENTORY                   ?= localhost -c local
TARGET_DIR                  ?= playbooks
CLEANUP_LIST                ?= *.log .venv .ansible .pytest_cache __pycache__
CLEANUP_DIRS                ?= collections/ansible_collections
COMPONENT                   ?= $(shell find $(TARGET_DIR)/fixtures -maxdepth 1 -type d -exec basename {} \; 2>/dev/null | grep -v fixtures | sort | head -1)

# Ansible configuration
ANSIBLE_GALAXY_REQS         ?= requirements.yml
ANSIBLE_BUILDER_VERBOSITY   ?= 1
ANSIBLE_PARAMS              ?= -vv
ANSIBLE_LINT_PARAMS         ?=


# UI Icons
ICON_FOUND					:= "ðŸ“ "
ICON_FAILED					:= "âŒ "
ICON_SUCCESS				:= "âœ… "
ICON_WARNING				:= "âš ï¸ "
ICON_CLEAN					:= "ðŸ§¹ "
ICON_CLEAN_DEEP				:= "ðŸ—‘ï¸ "
ICON_INFO					:= "â„¹ï¸ "

# Text processing helpers
empty :=
space := $(empty) $(empty)
comma := ,

# Conditional configuration based on debug mode
ifeq ($(SCRIPT_DEBUG),1)
	PODMAN_PARAMS += "--log-level" "debug"
	ANSIBLE_BUILDER_EXTRA_BUILD_CLI_ARGS += "--log-level" "debug"
	ANSIBLE_BUILDER_VERBOSITY = 3
endif

# Derived variables
ANSIBLE_BUILDER_EXTRA_BUILD_CLI_ARGS := $(PODMAN_BUILD_PARAMS) --build-arg-file ../$(BUILD_ARGS_FILE)
BUILD_ARGS_FILE_HEADER      := \# Build arguments file generated by Makefile at $(BUILD_DATE)
EE_BUILD_ARGS_FILE_HEADER   := \# Additional ansible-builder Execution Environment build arguments generated by Makefile at $(BUILD_DATE)

################################################################################
# SECTION 2: TEMPLATES & MACROS
################################################################################

# Newline template for file generation
define NEWLINE


endef

# Build arguments template for container builds
define BUILD_ARGS_TEMPLATE
$(if $(BASE_IMAGE),BASE_IMAGE=$(BASE_IMAGE))
$(if $(BASE_TAG),BASE_TAG=$(BASE_TAG))
$(if $(IMAGE_PYTHON_VERSION),PYTHON_VERSION=$(IMAGE_PYTHON_VERSION))
$(if $(IMAGE_VENV_ENABLE),VENV_ENABLE=$(IMAGE_VENV_ENABLE))
$(if $(VENV_DIR),VENV_DIR=$(VENV_DIR))
$(if $(GIT_WEB_URL),GIT_WEB_URL=$(GIT_WEB_URL))
$(if $(GIT_COMMIT_HASH),GIT_COMMIT_HASH=$(GIT_COMMIT_HASH))
$(if $(BUILD_DATE),BUILD_DATE=$(BUILD_DATE))
$(if $(BUILD_EPOCH),BUILD_EPOCH=$(BUILD_EPOCH))
$(if $(PKG_MANAGER),PKG_MANAGER=$(PKG_MANAGER))
$(if $(PKG_MANAGER_OPTS),PKG_MANAGER_OPTS=$(PKG_MANAGER_OPTS))
endef

# EE-specific environment variables template
define EE_BUILD_ARGS_TEMPLATE
$(if $(ANSIBLE_HOST_KEY_CHECKING),ANSIBLE_HOST_KEY_CHECKING=$(ANSIBLE_HOST_KEY_CHECKING))
$(if $(ANSIBLE_STDOUT_CALLBACK),ANSIBLE_STDOUT_CALLBACK=$(ANSIBLE_STDOUT_CALLBACK))
$(if $(ANSIBLE_COLLECTIONS_PATH),ANSIBLE_COLLECTIONS_PATH=$(ANSIBLE_COLLECTIONS_PATH))
$(if $(ANSIBLE_ROLES_PATH),ANSIBLE_ROLES_PATH=$(ANSIBLE_ROLES_PATH))
$(if $(PYTHONUNBUFFERED),PYTHONUNBUFFERED=$(PYTHONUNBUFFERED))
$(if $(PYTHONDONTWRITEBYTECODE),PYTHONDONTWRITEBYTECODE=$(PYTHONDONTWRITEBYTECODE))
endef

################################################################################
# SECTION 3: FUNCTIONS
################################################################################

# Helper function to split comma-separated values
define split_by_comma
$(subst $(comma),$(space),$(1))
endef

# Generic command execution with logging and error handling
# Usage: $(call run_cmd,command_description,cmd_array_var)
define run_cmd
	@$(eval message := $(1))
	@$(eval cmd := $(2))
	@printf '%s %s\n' "$(ICON_INFO)" "$(message)"
	@if [[ $(SCRIPT_DEBUG) -gt 0 ]]; then
		@echo "Running command: $${$(cmd)[@]}"
	@fi
	@if [ $(DRY_RUN) -gt 0 ]; then
		@printf '%s %s completed (DRY_RUN=%s)\n' "$(ICON_INFO)" "$(message)" "$(DRY_RUN)"
		@if [[ $(SCRIPT_DEBUG) -eq 0 ]]; then
			@echo "$(ICON_WARNING) If you want to see the command that would have been run, set SCRIPT_DEBUG=1"
		@fi
		@exit 0
	@fi
	@if ! "$${$(cmd)[@]}"; then
		@printf '%s %s failed\n' "$(ICON_FAILED)" "$(message)"
		@exit 1
	@fi
	@printf '%s %s completed\n' "$(ICON_SUCCESS)" "$(message)"
endef

# Virtual environment activation helper
# Usage: $(call with_venv,command_to_run)
define with_venv
	@source $(VENV_DIR)/bin/activate && echo "Venv $(VENV_DIR) activated"
	@source $(VENV_DIR)/bin/activate && $(1)
endef

# File existence check helper
# Usage: $(call require_file,filepath,error_message)
define require_file
	@if [[ ! -f "$(1)" ]]; then
		@echo "$(ICON_FAILED) $(2)"
		@exit 1
	@fi
endef

# Image tagging with smart defaults and duplicate detection
# Usage: $(call image_tag,src_name,src_tag,dst_name,dst_tag)
define image_tag
	@$(eval image_src_name := $(1))
	@$(eval image_src_tag := $(2))
	@$(eval image_dst_name := $(if $(3),$(3),$(1)))
	@$(eval image_dst_tag := $(if $(4),$(4),latest))

	@if [[ "$(image_src_name):$(image_src_tag)" == "$(image_dst_name):$(image_dst_tag)" ]]; then
		@echo "$(ICON_INFO) Skip: src and dst are identical ($(image_src_name):$(image_src_tag))"
	@else
		@CMD=(podman $(PODMAN_PARAMS) tag $(PODMAN_TAG_PARAMS) "$(image_src_name):$(image_src_tag)" "$(image_dst_name):$(image_dst_tag)")
		@$(call run_cmd,Tagging $(image_src_name):$(image_src_tag) â†’ $(image_dst_name):$(image_dst_tag),CMD)
	@fi
endef

# Image building with consistent error handling
# Usage: $(call image_build,image_name,image_tag,build_args_file)
define image_build
	@$(eval image_name := $(1))
	@$(eval image_tag := $(if $(2),$(2),$(GIT_COMMIT_HASH)))
	@$(eval build_args_file := $(if $(3),$(3),$(BUILD_ARGS_FILE)))
	@$(eval build_args := \
		$(if $(BASE_IMAGE), --build-arg BASE_IMAGE="$(BASE_IMAGE)") \
		$(if $(BASE_TAG), --build-arg BASE_TAG="$(BASE_TAG)") \
		$(if $(IMAGE_PYTHON_VERSION), --build-arg PYTHON_VERSION="$(IMAGE_PYTHON_VERSION)") \
		$(if $(IMAGE_VENV_ENABLE), --build-arg VENV_ENABLE="$(IMAGE_VENV_ENABLE)") \
		$(if $(VENV_DIR), --build-arg VENV_DIR="$(VENV_DIR)") \
		$(if $(GIT_WEB_URL), --build-arg GIT_WEB_URL="$(GIT_WEB_URL)") \
		$(if $(GIT_COMMIT_HASH), --build-arg GIT_COMMIT_HASH="$(GIT_COMMIT_HASH)") \
		$(if $(BUILD_DATE), --build-arg BUILD_DATE="$(BUILD_DATE)") \
		$(if $(BUILD_EPOCH), --build-arg BUILD_EPOCH="$(BUILD_EPOCH)") \
		$(if $(PKG_MANAGER), --build-arg PKG_MANAGER="$(PKG_MANAGER)") \
		$(if $(PKG_MANAGER_OPTS), --build-arg PKG_MANAGER_OPTS="$(PKG_MANAGER_OPTS)") \
	)
	@echo "$(ICON_INFO) Building image: $(image_name):$(image_tag)"
	@echo "$(ICON_INFO) Using build args: $(build_args)"
	@CMD=(podman $(PODMAN_PARAMS) build $(PODMAN_BUILD_PARAMS) $(build_args) "--tag" "$(image_name):$(image_tag)" "--file" "Containerfile" ".")
	@$(call run_cmd,Building $(image_name):$(image_tag),CMD)
endef

# Image pushing with tag list support
# Usage: $(call image_push,image_name,tag1,tag2,...)
define image_push
	@$(eval image_name := $(1))
	@$(eval tag_list := $(if $(2),$(2) $(3) $(4) $(5),$(GIT_COMMIT_HASH)))

	@for image_tag in $(tag_list); do
		@CMD=(podman $(PODMAN_PARAMS) push $(PODMAN_PUSH_PARAMS) "$(image_name):$${image_tag}")
		@$(call run_cmd,Pushing $(image_name):$${image_tag},CMD)
	@done
endef

# Python requirements update using pip-tools
# Usage: $(call python_requirements_update,context_name,requirements_list)
define python_requirements_update
	@echo "$(ICON_INFO) Running python requirements update on $(1)"
	@$(call with_venv,true)
	@$(eval reqs_to_update := $(call split_by_comma,$(2)))
	@if [ -z "$(reqs_to_update)" ]; then
		@echo "$(ICON_WARNING) No requirements specified for update in $(1)"
		@exit 1
	@fi
	@for req in $(reqs_to_update); do
		@$(call require_file,$${req}.in,Missing requirements file $${req}.in)
		@echo "$(ICON_INFO) Updating python dependencies for $${req}.txt"
		@CMD=(pip-compile --strip-extras)
		@if [[ -f $${req}.txt ]]; then CMD+=(--upgrade); else CMD+=(--annotate); fi
		@CMD+=($${req}.in -o $${req}.txt)
		@if [[ $(SCRIPT_DEBUG) -gt 0 ]]; then CMD+=(--verbose); fi
		@$(call run_cmd,Updating $${req}.txt,CMD)
	@done
endef

# Ansible command execution with environment setup
# Usage: $(call ansible_cmd,command_description,cmd_array_var,log_path)
define ansible_cmd
	@$(call with_venv,echo "Ansible environment ready")
	@$(if $(strip $(3)),ANSIBLE_FORCE_COLOR=false ANSIBLE_LOG_PATH=$(3) ANSIBLE_STDOUT_CALLBACK=minimal) $(call run_cmd,$(1),$(2))
endef

# Test discovery and execution
# Usage: $(call discover_and_run_tests,target_dir,playbook,component)
define discover_and_run_tests
	@$(eval target_dir := $(if $(1),$(1),$(TARGET_DIR)))
	@$(eval playbook := $(if $(2),$(2),$(if $(TEST_PLAYBOOK),$(TEST_PLAYBOOK),test_$(RUN_PLAYBOOK))))
	@$(eval component := $(if $(3),$(3),$(if $(COMPONENT),$(COMPONENT),$(CI_TYPE))))

	@echo "$(ICON_INFO) Auto-discovering tests in $(target_dir)"
	@$(call with_venv,echo "Test environment ready")

	@if find $(target_dir) -maxdepth 1 -name "$(playbook)" | grep -q .; then
		@echo "$(ICON_FOUND) Found E2E Tests Ansible playbooks"
		@$(MAKE) -f $(MAKEFILE_LIST) run-ansible-e2e-test TARGET_DIR=$(target_dir) TEST_PLAYBOOK=$(playbook) COMPONENT=$(component)
	@fi

	@for role_dir in $(target_dir)/roles/*; do
		@if find $(role_dir)/tests -name "test_*.py" 2>/dev/null | grep -q .; then 
			@echo "$(ICON_FOUND) Found Python tests, running pytest"
			@$(call with_venv,$(PY_EXEC) -m pytest $(role_dir)/tests)
		@fi

		@if [ -f "$(role_dir)/tests/test.yml" ]; then
			@echo "$(ICON_FOUND) Found role tests under $(role_dir)/tests/test.yml"
			@echo "Running ansible-playbook"
			@$(call ansible_cmd,Running role tests,ansible-playbook -i localhost -c local $(role_dir)/tests/test.yml,)
		@fi
	@done
endef

# Test verification helper
# Usage: $(call run_test_verification,target_dir,playbook,component)
define run_test_verification
	@$(eval target_dir := $(if $(1),$(1),$(TARGET_DIR)))
	@$(eval playbook := $(if $(2),$(2),$(if $(PLAYBOOK),$(PLAYBOOK), $(target_dir)/test_$(RUN_PLAYBOOK))))
	@$(eval component := $(if $(3),$(3),$(if $(COMPONENT), $(COMPONENT),$(CI_TYPE))))
	@echo "$(ICON_INFO) Running test verification for COMPONENT=$(component)"
	@$(eval expected := $(target_dir)/fixtures/$(component)/event.json)
	@$(eval actual := $(target_dir)/actual-event.json)
	@if [ ! -f $(expected) ]; then
		@echo "$(ICON_WARNING) No expected file $(expected) found, skipping verification"
		@exit 1
	@fi	
	@if [ ! -f $(actual) ]; then
		@echo "$(ICON_WARNING) No actual file $(actual) found, skipping verification"
		@exit 1
	@fi
	@echo "$(ICON_INFO) Verifying $(actual) against $(expected)"
	@if ! diff --color --unified $(expected) $(actual); then
		@echo "$(ICON_FAILED) Test verification failed for playbook $(playbook)"
		@exit 1
	@fi
	@echo "$(ICON_SUCCESS) Test verification passed for playbook $(playbook)"
endef

# Run ansible-playbook with standardized parameters
# Usage: $(call run_ansible_playbook,target_dir,playbook,component,extra_vars_file)
define run_ansible_playbook
	@$(eval target_dir := $(if $(1),$(1),$(TARGET_DIR)))
	@$(eval playbook_file := $(if $(2),$(2),$(RUN_PLAYBOOK)))
	@$(eval component := $(if $(3),$(3),$(if $(COMPONENT),$(COMPONENT),default)))
	@$(eval playbook_path := $(target_dir)/$(playbook_file))
	@$(eval extra_vars_file := $(if $(4),$(4),$(target_dir)/fixtures/$(component)/$(playbook_file)))
	
	@if [ ! -f "$(playbook_path)" ]; then
		@echo "$(ICON_FAILED) Playbook $(playbook_path) not found"
		@exit 1
	@fi
	@echo "$(ICON_INFO) Using PLAYBOOK=$(playbook_path)"
	
	@EXTRA_VARS_CHAIN=""
	@if [ -f "$(extra_vars_file)" ]; then
		@echo "$(ICON_INFO) Found extra vars file: $(extra_vars_file)"
		@EXTRA_VARS_CHAIN+=" -e @$(extra_vars_file)"
	@fi
	
	@if [ -f "$(target_dir)/fixtures/$(component)/env.bash" ]; then
		@echo "$(ICON_INFO) Sourcing $(target_dir)/fixtures/$(component)/env.bash"
		@set -a
		@source $(target_dir)/fixtures/$(component)/env.bash
		@set +a
	@fi
	
	# Set log path and execute ansible command
	@LOG_PATH=$(basename $(notdir $(playbook_path))).$(component).$(shell date +%Y%m%d%H%M%S).log
	@echo "$(ICON_INFO) Using ANSIBLE_LOG_PATH=$(LOG_PATH)"
	@CMD=(ansible-playbook -i $(INVENTORY) $(playbook_path) $${EXTRA_VARS_CHAIN} $(ANSIBLE_PARAMS))
	@$(call ansible_cmd,Running playbook $(playbook_file) for component $(component),CMD,$(LOG_PATH))
endef

# Run tests for specific component
# Usage: $(call run_component_tests,target_dir,playbook,component)
define run_component_tests
	@$(eval target_dir := $(if $(1),$(1),$(TARGET_DIR)))
	@$(eval playbook := $(if $(2),$(2),test_$(RUN_PLAYBOOK)))
	@$(eval component := $(if $(3),$(3),$(if $(COMPONENT),$(COMPONENT),default)))
	
	@echo "$(ICON_INFO) Running tests for component: $(component)"
	@$(call run_ansible_playbook,$(target_dir),$(playbook),$(component))
	@$(call run_test_verification,$(target_dir),$(playbook),$(component))
endef

################################################################################
# SECTION 4: TARGETS
################################################################################

#------------------------------------------------------------------------------
# Build Arguments and Configuration Targets
#------------------------------------------------------------------------------

image-build-args-file:
	@echo "$(ICON_INFO) Generating build arguments file: $(BUILD_ARGS_FILE)"
	@$(if $(filter ee-%,$(MAKECMDGOALS)),\
		$(file > $(BUILD_ARGS_FILE),$(BUILD_ARGS_FILE_HEADER)$(NEWLINE)$(BUILD_ARGS_TEMPLATE)$(NEWLINE)$(EE_BUILD_ARGS_FILE_HEADER)$(NEWLINE)$(subst $(space),$(NEWLINE),$(strip $(EE_BUILD_ARGS_TEMPLATE)))), \
		$(file > $(BUILD_ARGS_FILE),$(BUILD_ARGS_FILE_HEADER)$(NEWLINE)$(BUILD_ARGS_TEMPLATE)))
	@echo "$(ICON_SUCCESS) Build arguments file generated"
	@if [ "$(SCRIPT_DEBUG)" -eq 1 ]; then
		@echo "=== Build Args Content ==="
		@cat $(BUILD_ARGS_FILE)
		@echo "========================="
	fi

#------------------------------------------------------------------------------
# Python Environment Targets
#------------------------------------------------------------------------------

venv-ensure:
	@echo "$(ICON_INFO) Ensuring venv $(VENV_DIR) is installed"
	@if [[ -d $(VENV_DIR) && $(RECREATE) -eq 0 ]]; then exit 0; fi
	@if [[ -d $(VENV_DIR) ]]; then rm -rf $(VENV_DIR); fi
	@mkdir -p $(VENV_DIR)
	@$(PY_EXEC) -m venv $(VENV_DIR)
	@$(call with_venv,$(PY_EXEC) -m pip install --upgrade pip)
	@for req in $(PY_REQS); do
		@$(call with_venv,$(PY_EXEC) -m pip install -r $${req}.txt);
	@done
	@echo "$(ICON_SUCCESS) Ensured venv $(VENV_DIR) is installed"

python-deps-update: venv-ensure
	@$(call python_requirements_update,$@,$(PY_REQS))

python-deps-update-ee: venv-ensure
	@$(call python_requirements_update,$@,$(EE_PY_REQS))

python-deps-update-interactive: venv-ensure
	@echo "$(ICON_INFO) Updating python dependencies interactively"
	@$(call with_venv,true)
	@for req in $(PY_REQS); do
		@$(call require_file,$${req}.in,Missing requirements file $${req}.in)
		@CMD=(pip-compile $${req}.in -o $${req}.txt --interactive)
		@if [ $(SCRIPT_DEBUG) -eq 1 ]; then CMD+=(--verbose); fi
		@$(call run_cmd,Updating $${req}.txt interactively,CMD)
	@done

python-deps-save: venv-ensure python-deps-update
	@echo "$(ICON_INFO) Saving python dependencies"
	@GIT_PAGER=cat git diff {$(subst $(space),$(comma),$(PY_REQS))}.txt
	@git add {$(subst $(space),$(comma),$(PY_REQS))}.txt
	@git commit -s -m "Automatic Update of python dependencies done on $(shell date)" || {
		@echo "$(ICON_WARNING) Failed to commit python dependencies"
		@exit 1
	}
	@echo "$(ICON_SUCCESS) Saved python dependencies"

#------------------------------------------------------------------------------
# Ansible Environment Targets
#------------------------------------------------------------------------------

setup-ansible-deps: venv-ensure
	@echo "$(ICON_INFO) Installing Ansible collections from $(ANSIBLE_GALAXY_REQS)"
	@CMD=(ansible-galaxy collection install --force --pre -r $(ANSIBLE_GALAXY_REQS))
	@$(call ansible_cmd,Installing Ansible collections,CMD,)

bootstrap: setup-ansible-deps
	@echo "$(ICON_SUCCESS) Environment ready"

ansible-lint:
	@echo "$(ICON_INFO) Running ansible-lint on $(TARGET_DIR)"
	@CMD=(ansible-lint $(TARGET_DIR) $(ANSIBLE_LINT_PARAMS))
	@$(call ansible_cmd,Running ansible-lint on $(TARGET_DIR),CMD,)

#------------------------------------------------------------------------------
# Testing Targets
#------------------------------------------------------------------------------

test:
	@echo "$(ICON_INFO) Running tests in $(TARGET_DIR)"
	@$(call discover_and_run_tests,$(TARGET_DIR),$(if $(TEST_PLAYBOOK),$(TEST_PLAYBOOK),test_$(RUN_PLAYBOOK)),$(if $(COMPONENT),$(COMPONENT),$(CI_TYPE)))

test-verify:
	@echo "$(ICON_INFO) Verifying test results in $(TARGET_DIR)"
	@$(call run_test_verification,$(TARGET_DIR),$(if $(TEST_PLAYBOOK),$(TEST_PLAYBOOK),test_$(RUN_PLAYBOOK)),$(if $(COMPONENT),$(COMPONENT),$(CI_TYPE)))

retest:
	@$(MAKE) -f $(MAKEFILE_LIST) clean TARGET_DIR=$(TARGET_DIR)
	@$(MAKE) -f $(MAKEFILE_LIST) bootstrap
	@$(MAKE) -f $(MAKEFILE_LIST) test TARGET_DIR=$(TARGET_DIR)
	@$(MAKE) -f $(MAKEFILE_LIST) test-verify TARGET_DIR=$(TARGET_DIR)

run-ansible-e2e-test:
	@echo "$(ICON_INFO) Running Ansible E2E test for TARGET_DIR=$(TARGET_DIR)"
	@$(call with_venv,echo "Test environment ready")
	
	# Auto-discover component if not specified
	@$(eval COMPONENTS := $(shell find $(TARGET_DIR)/fixtures -maxdepth 1 -type d -exec basename {} \; 2>/dev/null | grep -v fixtures || echo ""))
	@$(eval COMPONENT := $(if $(COMPONENT),$(COMPONENT),$(word 1,$(COMPONENTS))))
	@$(eval EXT_VARS_FILE := $(if $(EXT_VARS_FILE),$(EXT_VARS_FILE),$(TARGET_DIR)/fixtures/$(COMPONENT)/$(TEST_PLAYBOOK)))
	
	@if [ -z "$(COMPONENT)" ]; then
		@echo "$(ICON_FAILED) No COMPONENT specified and no fixtures found in $(TARGET_DIR)/fixtures/"
		@exit 1
	@fi
	@echo "$(ICON_INFO) Using COMPONENT=$(COMPONENT) (available: $(COMPONENTS))"
	
	# Use enhanced run_ansible_playbook function with custom extra vars file
	@$(call run_ansible_playbook,$(TARGET_DIR),$(TEST_PLAYBOOK),$(COMPONENT),$(EXT_VARS_FILE))

run-all-e2e-tests:
	$(MAKE) -f $(MAKEFILE_LIST) run-ansible-e2e-test TEST_PLAYBOOK=test-report-send.yml COMPONENT=dci
	$(MAKE) -f $(MAKEFILE_LIST) run-ansible-e2e-test TEST_PLAYBOOK=test-report-send.yml COMPONENT=jenkins
	$(MAKE) -f $(MAKEFILE_LIST) run-ansible-e2e-test TEST_PLAYBOOK=test-time-conversion.yml COMPONENT=time-conversion

#------------------------------------------------------------------------------
# Container Image Targets
#------------------------------------------------------------------------------

image-tag:
	@IMAGE_TAG=$${IMAGE_TAG:-latest}
	@$(call image_tag,$(IMAGE_FULL_NAME),$(GIT_COMMIT_HASH),$(IMAGE_FULL_NAME),$${IMAGE_TAG})

image-build: image-build-args-file
	@$(call image_build,$(IMAGE_FULL_NAME),$(GIT_COMMIT_HASH),$(BUILD_ARGS_FILE))
	@$(MAKE) -f $(MAKEFILE_LIST) image-tag IMAGE_TAG=$${IMAGE_TAG:-latest}

image-push: image-build
	@$(eval IMAGE_TAG := $(if $${IMAGE_TAG},$${IMAGE_TAG},latest))
	@$(call image_push,$(IMAGE_FULL_NAME),$(GIT_COMMIT_HASH),$(IMAGE_TAG))

#------------------------------------------------------------------------------
# Execution Environment Targets
#------------------------------------------------------------------------------

ee-sync-requirements:
	@echo "$(ICON_INFO) Syncing requirements files for execution environment"
	@$(MAKE) -f $(MAKEFILE_LIST) python-deps-update-ee
	@cp requirements.yml $(EE_DIR)/requirements-ee.yml
	@cp requirements-ee.txt $(EE_DIR)/requirements-ee.txt
	@echo "$(ICON_SUCCESS) Requirements files synchronized"

ee-build: image-build-args-file venv-ensure ee-sync-requirements
	@$(call with_venv,echo "EE build environment ready")
	@echo "$(ICON_INFO) Building execution environment: $(EE_FULL_NAME):$(EE_TAG)"
	@echo "$(ICON_INFO) Using build args from: $(BUILD_ARGS_FILE)"
	@pushd $(PWD) >/dev/null
	@cd $(EE_DIR)
	@CMD=(ansible-builder build "--no-cache" "-t" "$(EE_FULL_NAME):$(EE_TAG)" "--extra-build-cli-args=$(ANSIBLE_BUILDER_EXTRA_BUILD_CLI_ARGS)" "-v" "$(ANSIBLE_BUILDER_VERBOSITY)")
	@$(call run_cmd,Building execution environment,CMD)
	@popd >/dev/null
	@$(call image_tag,$(EE_FULL_NAME),$(EE_TAG),$(EE_FULL_NAME),$(GIT_TAG))

ee-push: ee-build
	@IMAGE_TAG=$${GIT_TAG:-latest}
	@$(call image_push,$(EE_FULL_NAME),"$(EE_TAG),$${IMAGE_TAG}")

ee-clean:
	@echo "$(ICON_CLEAN) Cleaning execution environment build artifacts"
	@rm -rf $(EE_DIR)/build/
	@echo "$(ICON_SUCCESS) Build artifacts cleaned"

ee-info:
	@echo "Execution Environment Information:"
	@echo "  EE Directory: $(EE_DIR)"
	@echo "  EE Name: $(EE_NAME)"
	@echo "  EE Tag: $(EE_TAG)"
	@echo "  Full Image: $(EE_FULL_NAME):$(EE_TAG)"
	@echo "  Git Commit Hash: $(GIT_COMMIT_HASH)"
	@echo "  Git Tag (if any): $(GIT_TAG)"

ee-navigator-run:
	@echo "$(ICON_INFO) Running playbook $(EE_NAV_PLAYBOOK) using ansible-navigator with your EE ($(EE_NAME))"
	ansible-navigator run \
		--execution-environment-image $(EE_FULL_NAME):$(EE_TAG) \
		--mode $(EE_NAV_MODE) \
		--pull-policy $(EE_NAV_PULL_POLICY) \
		$(EE_NAV_PLAYBOOK) \
		$(EE_NAV_EXTRA_VARS)

ansible-nav-interactive:
	@ansible-navigator \
		--execution-environment-image $(EE_FULL_NAME):$(EE_TAG) \
		--mode interactive

#------------------------------------------------------------------------------
# Utility Targets
#------------------------------------------------------------------------------

clean:
	@echo "$(ICON_CLEAN) Cleaning test artifacts..."
	@if [ -n "$(TARGET_DIR)" ]; then
		@rm -rf "$(TARGET_DIR)/output"
	@else
		@echo "$(ICON_WARNING) TARGET_DIR not specified, skipping clean"
		@exit 1
	@fi
	@if [[ $(RECREATE) -ne 0 ]]; then
		@echo "$(ICON_CLEAN_DEEP) RECREATE=1: Deep clean mode"
		@echo "Also removing directories: $(CLEANUP_LIST)"
		@rm -rf $(CLEANUP_LIST)
	@fi
	@if [[ $(RECREATE) -ne 0 ]]; then
		@echo "$(ICON_CLEAN_DEEP) Removing directories: $(CLEANUP_DIRS)"
		@for folder in $(CLEANUP_DIRS)/*; do
			@rm -fr "$${folder}"
		@done
	@fi
	@echo "$(ICON_SUCCESS) Clean completed"

.PHONY: venv-ensure bootstrap clean test test-verify retest ansible-lint
.PHONY: image-build image-tag image-push image-build-args-file
.PHONY: ee-build ee-push ee-clean ee-info ee-navigator-run ansible-nav-interactive
.PHONY: python-deps-update python-deps-update-ee python-deps-update-interactive python-deps-save
.PHONY: setup-ansible-deps run-ansible-e2e-test
